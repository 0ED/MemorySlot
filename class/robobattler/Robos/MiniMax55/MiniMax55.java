
/*
 最終課題
 ファイル名：MiniMax55.java
 学生証番号:144155
 氏名:今江健悟
 説明:
 --名前について--
 MiniMax55 = "ミニマックス法を行動概念としているためです."
 このロボは各条件の判断をミニマックス法にしたがって行っています。
 ミニマックス法を基準に行動に動いているため、シンプルに"MiniMax"を名前にしました。
 "55"は学生証番号下2桁です.
 
 --アルゴリズム名--
 内部アルゴリズムは「フィードバック法」と名付けました。
 「フィードバック」 = "評価結果を、評価された本人に返すこと."
 このロボは実際の盤とは違うもう１つの盤で次の結果を評価し、最も高い結果になる座標を
 このロボに返します。次の盤の状態をフィードバックすることからこの名前をつけました。
 
 また、評価値の使い方としては「ミニマックス法」を利用しています。
 「ミニマックス法」 = 自分にとって良い指し手は相手にとって都合が悪く、逆もまたそうである
 という仮説に基づいたアルゴリズムです。自分の指し手では評価値が最大になるように選択し
 、相手の指し手では評価値が最小になるように選択する。
 
 感想/工夫した点：
 --このロボの戦略--
 MyBoardクラスというものを使い、盤の状態を記録し続けます。
 自分のマスは"1", 相手のマスは"-1", 空のマスは"0"のようにしていて
 このロボの爆撃する位置は一度、外部に用意されているボードを使い、全ての位置に爆撃した場合の
 中で盤の状態が最も自分に有利になる位置を選び爆撃するようにできています。
 全てのマス目の値を合計すると自分の値が"1", 相手が"-1"であるため、合計値(占拠率)が一番
 高い状況になるマス目に爆撃することが最善手であるというアルゴリズムです。
 
 例えば、自分の射ったミサイルの一部が画面外に出て無駄になるが、相手のマスを大きく塗りつぶせる
 場合や、相手の射ってきたミサイルと同じミサイルがきた場合に塗りつぶせる場合、相手のミサイルと
 同じミサイルが来たが、相手の射った位置に被せるより、もっと良い位置がある場合の判断をこのアル
 ゴリズムなら迷わず、最善手を実現しています。
 
 同じ方法で相手の爆撃した位置の誤差修正も相手が最も有利になる(占拠率が低い)座標に修正して
 相手の座標を読み込んでいます。このあたりの判断にミニマックス法を利用しています。
 
 --powerSearchTarget()の使いどころ--
 このロボはMyBoardを使い、盤の状況を記録し続けることによって最善手を決めています。
 初めの盤の状態を確実に正しいものにするため、初めに１度パワーサーチを使います。
 その後は、そこまでに記録した情報と新しく入ってくる情報ですこし、誤差が出てしまうが、最善手を
 打ち続けて、前半のプラスを維持します。その後、このゲームでは最後の状態で勝敗が決まるため
 後半で出来るだけ領地を獲得するため、最後にパワーサーチを使い切ります。
 
 --smartSearchTarget()について--
 このサーチは相手が爆撃してきた場合に誤差が含まれた状態で受け取る座標を最も相手に有利な位置
 に誤差修正するメソッドです。取得した座標に誤差が含まれている場合、その周囲１マスが真の座標
 であることがわかる。受け取った座標とその周囲の座標を使い、仮想盤に爆撃を行う。そのとき
 占拠率がもっとも相手に有利になる位置を相手の爆撃位置とする。強いロボが爆撃を行う場合
 もっとも自分に有利な爆撃になるように爆撃することが想定できるので、誤差がある真の座標がわか
 らないと考えるのではなく、相手はもっとも有利になるように爆撃するため、それを逆手にとり、
 最も相手に有利な位置に修正することでそれが相手の真の座標であるとすることができる。また
 最善手を取らないロボにたいしては無意味であり、こちらが不利になると思っていたが、実際に
 すこし弱いロボと戦ってみた結果、こちらの攻撃は常に最善手を射つため、圧倒することができた。
 強いロボにも勝つ為にはこの機能は必須であると考えた。弱いロボと戦う場合は相手の情報と誤差が
 あったところで競り勝てるとして、強いロボと戦う場合はすこしの誤差が敗因になると考えて
 このサーチを普通のサーチの代わりに使っている。
 
 --プログラムの可読性を上げる--
 初めにこのロボのプログラムを組んだ時は無数の条件分岐などが乱立していて非常に見にくい状態
 でした。そのため、複数の条件(かぶせる場合、相手のマスを奪う、空マスを狙う、自分のマスにかぶ
 せても意味がない)などの判断をif文などで無数に場合分けしていたのですが、量が増えてくると
 ものすごく見にくく、後で修正する場合に、見てわかるようなものではありませんでした。
 そのため、上記の判断を条件分岐に頼ることなく区別できる方法はないかと思考錯誤したあげく
 MyBoardクラスを作成し、そちらの盤で得た情報(占拠率)を用いて、もっとも占拠率が高くなる一手
 が最善手であるとするアルゴリズムを基準に複数の条件分岐を１つに集約しました。
 結果、actionメソッド内はプログラムの流れがわかりやすい範囲で、できるだけ見やすくしました.
 
 --即死攻撃(不戦敗狙い)について--
 このゲームではパスができ、パスをした場合にはsearchTarget()がわからなくなる仕組みでした。
 これは先攻、後攻の判断にしか使われていなかったため、初めの一発目が後攻なら、
 一発目なのでパスをして、相手が先攻、後攻の判断だけしかしていなかった場合にこちらのパスで
 相手にエラーを起こさせ、ルール上実行エラーをおこしたロボは負けとなるということだったの
 先攻だった場合は普通に攻撃し、後攻が回ってきた時にパスをして、相手の実行エラーによる
 不戦勝を狙うという戦略を予定していました。初めの一発は最悪撃たなくても、勝敗に影響する
 ようなデメリットにはならなかったため、逆に対策していなかったロボに不戦勝できるということ
 で即死攻撃を狙っていました。修正が入るということらしいの、すこしでも不利になる戦略を
 組込むのは得策ではなかったため、廃止しました。
 ソースは削除してしまいましたが、turnが1のときで先攻ではない場合にfire()しないと
 いうif文を書いていただけです。
 
 --注意点--
 盤の状態を16回毎に初期化しているので,[manual start]で16回以上キーを押すのは
 勘弁してください。仮想盤の状態がおかしくなるため、正常な思考を維持できなくなります。
 そうなると一度終了しないと復帰できません。[auto start]を連続7回押す場合については
 バグは発見されなかったので問題ありません。１試合終わるごとの判定を受け取れないため、
 苦肉の策です。
 
 参考元:
 Algorithms with Python / ミニマックス法とαβ法
 http://www.geocities.jp/m_hiroi/light/pyalgo24.html
 
 */

import robobattler2.*;
import java.awt.Point;

public class MiniMax55 extends Robo{
    //定数
    public static final int SIZE = 9;//マス目の数
    //フィールド
    private Point target = new Point(4, 4);//相手の着弾地点を受け取るフィールド
    private MyBoard board = new MyBoard();//現在のボードの状態を保存するフィールド
    private int turn = 1;//ターンを表すフィールド
    private CheckLine checkLine = new CheckLine();//Line型の判定を行うオブジェクト
    private boolean tate = false;//Lineの縦横決めるフィールド
    
    
    /**
     ロボの行動を決めるメソッド
     @param missile 受け取ったミサイルオブジェクト
     */
    protected void action(Missile missile){
        //２回目からは初期化する
        if(turn > 16){turn = 1; board = new MyBoard();}
        
        checkLineMissile(-1, missile);//サーチするため相手の縦横を決める
        
        if(turn == 1 || turn > 12){//初めの座標と後半に使い切る
            target = powerSearchTarget();//相手の座標を受け取る
        }else{//パワーサーチを使わない場合
            target = smartSearchTarget();//誤差を修正したサーチ
        }
        
        if(target == null){//先攻の場合
            firstFire(missile.getType());
        }else{//それ以外の場合
            board.set(target, -1, searchType(), false);//相手の座標を保存
            checkLineMissile(1, missile);//自分の番の縦横決定
            bestFire(missile.getType());//自分の爆撃
        }
        
        board.show();
        System.out.println("現在の占拠率は["+board.getTotal()+"]です.");
        turn++;//ターンがたったことを数える
    }
    
    /**
     先攻の場合のメソッド
     @param type ミサイルのタイプを表す
     */
    private void firstFire(int type){
        System.out.println("先攻です!!");
        if(type == 1){
            fire(3, 0);
            board.set(new Point(3, 0), 1, type, false);//端に射つ
        }else{
            fire(4, 4);
            board.set(new Point(4, 4), 1, type, false);//真ん中に射つ
        }
        
    }
    
    /**
     最も占拠率が上がる様に撃つメソッド
     @param type ミサイルのタイプを表す
     */
    private void bestFire(int type){
        int total;//現在の仮想盤の占拠率(初期化しないのは全てが-の場合があるため)
        int x=0,y=0;//爆撃する座標
        
        MyBoard copy = new MyBoard(board.getBoard());//ボードを複製する
        copy.set(new Point(0,0), 1, type, tate);//複製したものに爆撃する(0,0)
        int tmp = copy.getTotal();//その時の占拠率を得る
        //他のマスに爆撃した場合の占拠率を調べる
        for(int j = 0; j < SIZE; j++){
            for(int i = 0; i < SIZE; i++){
                copy = new MyBoard(board.getBoard());//ボードの状態を巻き戻す
                copy.set(new Point(i,j), 1, type, tate);//再度爆撃する
                total = copy.getTotal();//占拠率を得る
                if(tmp < total){tmp = total; x=i; y=j;}//占拠率が高いなら入れ替える
            }
        }
        fire(x, y);
        board.set(new Point(x, y), 1, type, tate);//最も高い座標に爆撃する
    }
    
    /**
     最も占拠率が相手に有利になる位置をサーチするメソッド
     @return 誤差修正した相手の爆撃位置を表すオブジェクト
     */
    private Point smartSearchTarget(){
        int total;//現在の仮想盤の占拠率
        int x=0,y=0;//爆撃する座標
        int type = searchType();//相手のミサイルタイプを受け取る
        Point target = new Point();//ターゲットの座標
        
        target = searchTarget();//爆撃された座標を受け取る
        x = target.x; y = target.y;//その時の座標を取り出す
        
        MyBoard copy = new MyBoard();//ボードを複製する
        copy.set(new Point(x-1, y-1), -1, type, false);//爆撃された位置の左上を保存
        int tmp = copy.getTotal();//その時の占拠率を受け取る
        
        for(int j = y-1; j <= y+1; j++){//取得した座標の周囲の座標を見ていく
            for(int i = x-1; i <= x+1; i++){
                copy = new MyBoard(board.getBoard());//ボードの状態を巻き戻す
                copy.set(new Point(i, j), -1, type, false);//再度座標を見てみる
                total = copy.getTotal();//占拠率を得る
                //占拠率が低い(相手に有利な位置なら入れ替え)
                if(tmp > total){tmp = total; target = new Point(i, j);}
            }
        }
        
        return target;//誤差修正した座標を渡す
    }
    
    
    /**
     Line型のミサイルの縦横判定を行うメソッド
     @param player "1"なら自分の判定, それ以外は相手の判定
     @param missile ミサイルオブジェクト
     */
    private void checkLineMissile(int player, Missile missile){
        //"1"が自分, "-1"が相手とMyboardの基準に合わせています。
        if(player == 1){
            //自分のLineの縦横を決める
            tate = checkLine.check(board);
        }else{
            //相手のLineの縦横を決める
            tate = checkLine.check(searchTarget(), board);
        }
        
        if(tate){
            missile.setVertical();//trueなら縦撃ちに設定
        }else{
            missile.setHorizontal();//falseなら横撃ちに設定
        }
    }
    
    
    //----終わり----
}